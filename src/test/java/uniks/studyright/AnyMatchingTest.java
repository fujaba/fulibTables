package uniks.studyright;

import org.fulib.FulibTables;
import org.fulib.patterns.PatternBuilder;
import org.fulib.patterns.PatternMatcher;
import org.fulib.patterns.model.PatternObject;
import org.fulib.tables.ObjectTable;
import org.fulib.yaml.Reflector;
import org.fulib.yaml.ReflectorMap;
import org.junit.Before;
import org.junit.Test;
import uniks.studyright.model.Room;
import uniks.studyright.model.Student;
import uniks.studyright.model.University;

import java.util.*;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotSame;

public class AnyMatchingTest
{
   private Object[] roots;
   private Object[] all;
   private University studyRight;
   private Student alice;

   @Before
   public void scenario()
   {
      // --- end of code generated by solution scenario ---
      University studyRight = new University();
      studyRight.setName("StudyRight");

      Student alice = new Student();
      alice.setName("Alice");
      alice.setCredits(20);

      Student bob = new Student();
      bob.setName("Bob");
      bob.setCredits(10);

      studyRight.withStudents(alice, bob);

      for (int i = 0; i < 5; i++)
      {
         studyRight.withRooms(new Room().setTopic("T" + i).setRoomNo("R" + i).setCredits(i * 10));
      }
      // --- end of code generated by solution scenario ---

      this.studyRight = studyRight;
      this.alice = alice;
      // captured by fulibScenarios
      this.roots = new Object[] { studyRight, alice, bob };
      this.all = findAll(this.roots);
   }

   @Test
   public void knownObjectKnownAttribute()
   {
      // Normal case, already generated by fulibScenarios

      // We expect that studyRight has name "StudyRight".
      assertEquals("StudyRight", this.studyRight.getName());
   }

   @Test
   public void knownObjectUnknownAttribute()
   {
      // We expect that studyRight has some attribute with value "StudyRight".

      final PatternBuilder builder = FulibTables.patternBuilder();

      final PatternObject studyRight = builder.buildPatternObject("studyRight");
      final PatternObject studyRightAttr1 = builder.buildPatternObject("studyRightAttr1");

      builder.buildEqualityConstraint(studyRightAttr1, "StudyRight");
      builder.buildPatternLink(studyRight, null, "*", studyRightAttr1);

      final PatternMatcher matcher = FulibTables.matcher(builder.getPattern());
      final ObjectTable match = matcher.match("studyRight", this.studyRight);
      assertEquals(1, match.rowCount());

      // this is not part of the generated code, but a sanity check:
      assertEquals(Collections.singletonList(this.studyRight), match.toList());
   }

   @Test
   public void unknownObjectKnownAttribute()
   {
      // We expect that there is some object c20 with 20 credits.

      final PatternBuilder builder = FulibTables.patternBuilder();
      final PatternObject c20 = builder.buildPatternObject("c20");
      final PatternObject c20Credits = builder.buildPatternObject("c20Credits");

      builder.buildEqualityConstraint(c20Credits, 20.0);
      builder.buildPatternLink(c20, null, "credits", c20Credits);

      final PatternMatcher matcher = FulibTables.matcher(builder.getPattern());
      final ObjectTable match = matcher.match("c20", this.roots);
      assertEquals(1, match.rowCount());

      // sanity check, not part of generated code:
      assertEquals(Collections.singletonList(this.alice), match.toList());
   }

   @Test
   public void nonRootObjectKnownAttribute()
   {
      // We expect that there is some object r3 with roomNo R3.

      final PatternBuilder builder = FulibTables.patternBuilder();
      final PatternObject r3 = builder.buildPatternObject("r3");
      final PatternObject r3RoomNo = builder.buildPatternObject("r3RoomNo");

      builder.buildEqualityConstraint(r3RoomNo, "R3");
      builder.buildPatternLink(r3, null, "roomNo", r3RoomNo);

      final PatternMatcher matcher = FulibTables.matcher(builder.getPattern());
      final ObjectTable match = matcher.match(r3, this.all);
      assertEquals(1, match.rowCount());
   }

   @Test
   public void unknownObjectsUnknownAttributes()
   {
      final PatternBuilder builder = FulibTables.patternBuilder();

      // We expect that there is some object studyRight
      final PatternObject studyRight = builder.buildPatternObject("studyRight");

      // that has some attribute with value "StudyRight".
      final PatternObject studyRightAttr1 = builder.buildPatternObject("studyRightAttr1");
      builder.buildEqualityConstraint(studyRightAttr1, "StudyRight");
      builder.buildPatternLink(studyRight, null, "*", studyRightAttr1);

      // We expect that there is some object alice
      final PatternObject alice = builder.buildPatternObject("alice");

      // that has some attribute with value "Alice"
      final PatternObject aliceAttr1 = builder.buildPatternObject("aliceAttr1");
      builder.buildEqualityConstraint(aliceAttr1, "Alice");
      builder.buildPatternLink(alice, null, "*", aliceAttr1);

      // and that has some attribute with value 10.
      final PatternObject aliceAttr2 = builder.buildPatternObject("aliceAttr2");
      builder.buildEqualityConstraint(aliceAttr2, 20.0);
      builder.buildPatternLink(alice, null, "*", aliceAttr2);

      // We expect that there is some object bob
      final PatternObject bob = builder.buildPatternObject("bob");

      // that has some attribute with value "Bob"
      final PatternObject bobName = builder.buildPatternObject("bobName");
      builder.buildEqualityConstraint(bobName, "Bob");
      builder.buildPatternLink(bob, null, "*", bobName);

      // and that has some attribute with value 20.
      final PatternObject bobCredits = builder.buildPatternObject("bobCredits");
      builder.buildEqualityConstraint(bobCredits, 10.0);
      builder.buildPatternLink(bob, null, "*", bobCredits);

      // We expect that studyRight has some link to alice and bob.
      builder.buildPatternLink(studyRight, null, "*", alice);
      builder.buildPatternLink(studyRight, null, "*", bob);

      // Do match

      PatternMatcher matcher = FulibTables.matcher(builder.getPattern());
      ObjectTable start = matcher.match("studyRight", this.roots);
      assertEquals(1, start.rowCount());

      System.out.println(start);
   }

   // the expected AssertionError would not be generated.
   // It is here because we expect the generated code to fail.
   @Test(expected = AssertionError.class)
   public void ambiguousMatch()
   {
      // We expect that there is some object a20 that has some attribute with value 20.
      // (that would be Alice and R2 both with 20 credits)

      final PatternBuilder builder = FulibTables.patternBuilder();
      final PatternObject a20 = builder.buildPatternObject("a20");
      final PatternObject a20Attr1 = builder.buildPatternObject("a20Attr1");

      builder.buildEqualityConstraint(a20Attr1, 20.0);
      builder.buildPatternLink(a20, "*", a20Attr1);

      final PatternMatcher matcher = FulibTables.matcher(builder.getPattern());
      final ObjectTable match = matcher.match(a20, this.all);
      assertEquals(1, match.rowCount());
   }

   @Test
   public void multiMatch()
   {
      // We expect that there are some objects a20 and r20 that have some attribute with value 20.
      // (that would be Alice and R2 both with 20 credits)

      final PatternBuilder builder = FulibTables.patternBuilder();

      final PatternObject a20 = builder.buildPatternObject("a20");
      final PatternObject a20Attr1 = builder.buildPatternObject("a20Attr1");

      builder.buildEqualityConstraint(a20Attr1, 20.0);
      builder.buildPatternLink(a20, "*", a20Attr1);

      final PatternObject r20 = builder.buildPatternObject("r20");
      final PatternObject r20Attr1 = builder.buildPatternObject("r20Attr1");

      builder.buildEqualityConstraint(r20Attr1, 20.0);
      builder.buildPatternLink(r20, "*", r20Attr1);

      // because a20 and r20 are used in the same sentence, we interpret them as being two different objects:
      builder.buildInequalityConstraint(a20, r20);
      // had the sentence(s) been:
      // We expect that there is some object a20 that has some attribute with value 20.
      // We expect that there is some object r20 that has some attribute with value 20.
      // a20 would have been allowed to be the same as r20.

      final PatternMatcher matcher = FulibTables.matcher(builder.getPattern());
      matcher.getRootPatternObjects().add(a20);
      matcher.getRootPatternObjects().add(r20);
      Collections.addAll(matcher.getRootObjects(), this.all);
      matcher.match();
      final ObjectTable a20Result = matcher.getMatchTable(a20);
      final ObjectTable r20Result = matcher.getMatchTable(r20);

      // there can be 2 results,
      // - a20=Alice and r20=R2
      // - a20=R2 and r20=Alice
      // both are equally valid without further specification
      assertEquals(2, a20Result.rowCount());

      // sanity check:

      assertNotSame(a20Result.iterator().next(), r20Result.iterator().next());
   }

   // --------------- Helper Methods ---------------

   private static Object[] findAll(Object... roots)
   {
      // TODO consider other package names
      final ReflectorMap reflectorMap = new ReflectorMap(roots[0].getClass().getPackage().getName());
      final Set<Object> out = new HashSet<>();
      for (final Object root : roots)
      {
         findNeighbors(reflectorMap, root, out);
      }
      return out.toArray();
   }

   // TODO maybe this would be a good addition to Reflector, e.g. getTransitiveNeighbors()?
   private static void findNeighbors(ReflectorMap map, Object root, Set<Object> out)
   {
      if (root == null || !map.canReflect(root))
      {
         return;
      }

      final Reflector reflector = map.getReflector(root);

      // doing this after the reflector prevents values from being added to the set
      if (!out.add(root))
      {
         return;
      }

      // TODO maybe this would be a good addition to Reflector, e.g. getNeighbors()?
      for (final String property : reflector.getAllProperties())
      {
         final Object value = reflector.getValue(root, property);
         if (value instanceof Collection)
         {
            for (Object item : (Collection<?>) value)
            {
               findNeighbors(map, item, out);
            }
         }
         else
         {
            findNeighbors(map, value, out);
         }
      }
   }
}
